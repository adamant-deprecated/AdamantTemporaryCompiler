//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by  the adamant-cc-lex tool.
//     Version: <%= GeneratorVersion %>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;

namespace <%= ClassNamespace %>
{
	[GeneratedCode("adamant-cc-lex", "<%= GeneratorVersion %>")]
	[DebuggerNonUserCode]
	[CompilerGenerated]
	public partial class <%= ClassName %> : Adamant.CompilerCompiler.Lex.Runtime.Lexer<<%= ClassName %>.Channel, <%= ClassName %>.TokenType>
	{
		public enum Channel
		{
			<%= Channels %>
		}

		public enum TokenType
		{
			<%= TokenTypes %>
		}

		public enum Mode
		{
			<%= Modes %>
		}

		<%= PlaneOffsets %>
		private static readonly <%= EquivalenceClassType %>[] equivalenceTable =
		{
			<%= EquivalenceTable %>
		};

		private static readonly <%= RowMapType %>[] rowMap =
		{
			<%= RowMap %>
		};
		private static readonly <%= StateType %>[] transitions =
		{
			<%= Transitions %>
		};
		private static readonly <%= ActionMapType %>[] actionMap =
		{
			<%= ActionMap %>
		};

		private const int ErrorState = <%= ErrorState %>;

		private readonly TextReader reader;
		private Mode currentMode = Mode.<%= InitialMode %>;
		private Stack<Mode> modeStack = new Stack<Mode>();
		private readonly StringBuilder tokenBuffer = new StringBuilder();
		private readonly StringBuilder captureBuffer = new StringBuilder();
		private int currentLine = 0;
		private int currentColumn = 0;

		public <%= ClassName %>(TextReader reader)
		{
			this.reader = reader;
		}

		public <%= ClassName %>(Stream stream)
			: this(new StreamReader(stream))
		{
		}

		public Mode CurrentMode
		{
			get { return currentMode; }
		}


		public void PushMode(Mode mode)
		{
			modeStack.Push(currentMode);
			currentMode = mode;
		}

		public void PopMode()
		{
			currentMode = modeStack.Pop();
		}

		public void SetMode(Mode mode)
		{
			currentMode = mode;
		}

		public override IEnumerator<Adamant.CompilerCompiler.Lex.Runtime.Token<Channel, TokenType>> GetEnumerator()
		{
			while(true)
				yield return NextToken();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private Adamant.CompilerCompiler.Lex.Runtime.Token<Channel, TokenType> NextToken()
		{
			var currentState = (int)currentMode;
			var afterCarriageReturn = false;
			while(true)
			{
				var maybeCodePoint = ReadCodePoint();
				if(maybeCodePoint == null)
					throw new NotImplementedException("EOF");

				var codePoint = maybeCodePoint.Value;

				afterCarriageReturn = TrackLineAndColumn(codePoint, afterCarriageReturn);
				var equivalenceClass = EquivalenceClass(codePoint);
				var nextState = transitions[rowMap[currentState] + equivalenceClass];
				var action = actionMap[nextState];
				Adamant.CompilerCompiler.Lex.Runtime.Token<Channel, TokenType> token = null;
				switch(action)
				{
					<%= Actions %>
					default:
						throw new InvalidOperationException();
				}
				tokenBuffer.Clear();

				// TODO generate (or not) the token
				if(token != null)
					return token;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private int? ReadCodePoint()
		{
			var codePoint = reader.Read();
			if(codePoint == -1) return null;

			var charValue = (char)codePoint;
			if(char.IsHighSurrogate(charValue))
			{
				var low = reader.Read();
				if(low == -1) return null;
				codePoint = char.ConvertToUtf32(charValue, (char)low);
			}
			return codePoint;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static int EquivalenceClass(int codePoint)
		{
			var plane = codePoint & 0x1F000;

			switch(plane)
			{
				<%= EquivalenceClassCases %>
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private bool TrackLineAndColumn(int codePoint, bool afterCarriageReturn)
		{
			switch(codePoint)
			{
				// TODO clarify these
				case '\u000B':
				case '\u000C':
				case '\u0085':
				case '\u2028':
				case '\u2029':
					currentLine++;
					currentColumn = 0;
					afterCarriageReturn = false;
					break;
				case '\r':
					currentLine++;
					currentColumn = 0;
					afterCarriageReturn = true;
					break;
				case '\n':
					if(afterCarriageReturn)
						afterCarriageReturn = false;
					else
					{
						currentLine++;
						currentColumn = 0;
					}
					break;
				default:
					afterCarriageReturn = false;
					currentColumn++;
					break;
			}
			return afterCarriageReturn;
		}
	}
}